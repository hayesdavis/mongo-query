# Autogenerated from a Treetop grammar. Edits may be lost.


module MongoQueryGrammar
  include Treetop::Runtime

  def root
    @root || :query
  end

  module Query0
    def space1
      elements[0]
    end

    def and_expression
      elements[1]
    end

    def space2
      elements[2]
    end
  end

  module Query1
    def to_mongo
      and_expression.to_mongo
    end
  end

  def _nt_query
    start_index = index
    if node_cache[:query].has_key?(index)
      cached = node_cache[:query][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_space
    s0 << r1
    if r1
      r2 = _nt_and_expression
      s0 << r2
      if r2
        r3 = _nt_space
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Query0)
      r0.extend(Query1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:query][start_index] = r0

    r0
  end

  module AndExpression0
    def binary_expression
      elements[0]
    end

    def space1
      elements[1]
    end

    def and_op
      elements[2]
    end

    def space2
      elements[3]
    end

    def and_expression
      elements[4]
    end
  end

  module AndExpression1
    def to_mongo
      res = binary_expression.to_mongo
      new_res = and_expression.to_mongo
      res.each do |key,value|
        if new_res.has_key?(key)
          value.merge!(new_res.delete(key))
        end
      end
      res.merge(new_res)
    end
  end

  def _nt_and_expression
    start_index = index
    if node_cache[:and_expression].has_key?(index)
      cached = node_cache[:and_expression][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_binary_expression
    s1 << r2
    if r2
      r3 = _nt_space
      s1 << r3
      if r3
        r4 = _nt_and_op
        s1 << r4
        if r4
          r5 = _nt_space
          s1 << r5
          if r5
            r6 = _nt_and_expression
            s1 << r6
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(AndExpression0)
      r1.extend(AndExpression1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r7 = _nt_binary_expression
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:and_expression][start_index] = r0

    r0
  end

  def _nt_and_op
    start_index = index
    if node_cache[:and_op].has_key?(index)
      cached = node_cache[:and_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('and', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('and')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('AND', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure('AND')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:and_op][start_index] = r0

    r0
  end

  module BinaryExpression0
    def field_name
      elements[0]
    end

    def space1
      elements[1]
    end

    def space2
      elements[3]
    end

    def literal
      elements[4]
    end
  end

  module BinaryExpression1
    def to_mongo
      {field_name.to_mongo=>literal.to_mongo}
    end
  end

  module BinaryExpression2
    def field_name
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def value
      elements[4]
    end
  end

  module BinaryExpression3
    def field_name
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def value
      elements[4]
    end
  end

  module BinaryExpression4
    def field_name
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def value
      elements[4]
    end
  end

  module BinaryExpression5
    def field_name
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def value
      elements[4]
    end
  end

  module BinaryExpression6
    def to_mongo
      {field_name.to_mongo=>{ operator.to_mongo => value.to_mongo }}
    end
  end

  def _nt_binary_expression
    start_index = index
    if node_cache[:binary_expression].has_key?(index)
      cached = node_cache[:binary_expression][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_field_name
    s1 << r2
    if r2
      r3 = _nt_space
      s1 << r3
      if r3
        if has_terminal?('=', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('=')
          r4 = nil
        end
        s1 << r4
        if r4
          r5 = _nt_space
          s1 << r5
          if r5
            r6 = _nt_literal
            s1 << r6
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(BinaryExpression0)
      r1.extend(BinaryExpression1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7 = index
      i8, s8 = index, []
      r9 = _nt_field_name
      s8 << r9
      if r9
        r10 = _nt_space
        s8 << r10
        if r10
          r11 = _nt_comp_op
          s8 << r11
          if r11
            r12 = _nt_space
            s8 << r12
            if r12
              r13 = _nt_literal
              s8 << r13
            end
          end
        end
      end
      if s8.last
        r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
        r8.extend(BinaryExpression2)
      else
        @index = i8
        r8 = nil
      end
      if r8
        r7 = r8
        r7.extend(BinaryExpression6)
      else
        i14, s14 = index, []
        r15 = _nt_field_name
        s14 << r15
        if r15
          r16 = _nt_space
          s14 << r16
          if r16
            r17 = _nt_list_op
            s14 << r17
            if r17
              r18 = _nt_space
              s14 << r18
              if r18
                r19 = _nt_list
                s14 << r19
              end
            end
          end
        end
        if s14.last
          r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
          r14.extend(BinaryExpression3)
        else
          @index = i14
          r14 = nil
        end
        if r14
          r7 = r14
          r7.extend(BinaryExpression6)
        else
          i20, s20 = index, []
          r21 = _nt_field_name
          s20 << r21
          if r21
            r22 = _nt_space
            s20 << r22
            if r22
              r23 = _nt_size_op
              s20 << r23
              if r23
                r24 = _nt_space
                s20 << r24
                if r24
                  r25 = _nt_integer
                  s20 << r25
                end
              end
            end
          end
          if s20.last
            r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
            r20.extend(BinaryExpression4)
          else
            @index = i20
            r20 = nil
          end
          if r20
            r7 = r20
            r7.extend(BinaryExpression6)
          else
            i26, s26 = index, []
            r27 = _nt_field_name
            s26 << r27
            if r27
              r28 = _nt_space
              s26 << r28
              if r28
                r29 = _nt_exists_op
                s26 << r29
                if r29
                  r30 = _nt_space
                  s26 << r30
                  if r30
                    r31 = _nt_boolean
                    s26 << r31
                  end
                end
              end
            end
            if s26.last
              r26 = instantiate_node(SyntaxNode,input, i26...index, s26)
              r26.extend(BinaryExpression5)
            else
              @index = i26
              r26 = nil
            end
            if r26
              r7 = r26
              r7.extend(BinaryExpression6)
            else
              @index = i7
              r7 = nil
            end
          end
        end
      end
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:binary_expression][start_index] = r0

    r0
  end

  module List0
    def space1
      elements[1]
    end

    def list_items
      elements[2]
    end

    def space2
      elements[3]
    end

  end

  module List1
    def to_mongo
      list_items.to_mongo
    end
  end

  def _nt_list
    start_index = index
    if node_cache[:list].has_key?(index)
      cached = node_cache[:list][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_space
      s0 << r2
      if r2
        r3 = _nt_list_items
        s0 << r3
        if r3
          r4 = _nt_space
          s0 << r4
          if r4
            if has_terminal?(')', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(')')
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(List0)
      r0.extend(List1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:list][start_index] = r0

    r0
  end

  module ListItems0
    def literal
      elements[0]
    end

    def space1
      elements[1]
    end

    def space2
      elements[3]
    end

    def list_items
      elements[4]
    end
  end

  module ListItems1
    def to_mongo
      [literal.to_mongo] + [list_items.to_mongo].flatten
    end
  end

  def _nt_list_items
    start_index = index
    if node_cache[:list_items].has_key?(index)
      cached = node_cache[:list_items][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_literal
    s1 << r2
    if r2
      r3 = _nt_space
      s1 << r3
      if r3
        if has_terminal?(',', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(',')
          r4 = nil
        end
        s1 << r4
        if r4
          r5 = _nt_space
          s1 << r5
          if r5
            r6 = _nt_list_items
            s1 << r6
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(ListItems0)
      r1.extend(ListItems1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r7 = _nt_literal
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:list_items][start_index] = r0

    r0
  end

  module CompOp0
    def to_mongo; '$lte'; end
  end

  module CompOp1
    def to_mongo; '$lt';  end
  end

  module CompOp2
    def to_mongo; '$gte'; end
  end

  module CompOp3
    def to_mongo; '$gt';  end
  end

  module CompOp4
    def to_mongo; '$ne';  end
  end

  def _nt_comp_op
    start_index = index
    if node_cache[:comp_op].has_key?(index)
      cached = node_cache[:comp_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('<=', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      r1.extend(CompOp0)
      @index += 2
    else
      terminal_parse_failure('<=')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('<', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        r2.extend(CompOp1)
        @index += 1
      else
        terminal_parse_failure('<')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?('>=', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
          r3.extend(CompOp2)
          @index += 2
        else
          terminal_parse_failure('>=')
          r3 = nil
        end
        if r3
          r0 = r3
        else
          if has_terminal?('>', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            r4.extend(CompOp3)
            @index += 1
          else
            terminal_parse_failure('>')
            r4 = nil
          end
          if r4
            r0 = r4
          else
            if has_terminal?('!=', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
              r5.extend(CompOp4)
              @index += 2
            else
              terminal_parse_failure('!=')
              r5 = nil
            end
            if r5
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:comp_op][start_index] = r0

    r0
  end

  def _nt_list_op
    start_index = index
    if node_cache[:list_op].has_key?(index)
      cached = node_cache[:list_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    r1 = _nt_in_op
    if r1
      r0 = r1
    else
      r2 = _nt_not_in_op
      if r2
        r0 = r2
      else
        r3 = _nt_all_op
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:list_op][start_index] = r0

    r0
  end

  module InOp0
    def to_mongo; "$in"; end
  end

  def _nt_in_op
    start_index = index
    if node_cache[:in_op].has_key?(index)
      cached = node_cache[:in_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('in', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('in')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('IN', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        r2.extend(InOp0)
        @index += 2
      else
        terminal_parse_failure('IN')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:in_op][start_index] = r0

    r0
  end

  module NotInOp0
    def to_mongo; "$nin"; end
  end

  def _nt_not_in_op
    start_index = index
    if node_cache[:not_in_op].has_key?(index)
      cached = node_cache[:not_in_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('not in', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure('not in')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('NOT IN', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 6))
        r2.extend(NotInOp0)
        @index += 6
      else
        terminal_parse_failure('NOT IN')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:not_in_op][start_index] = r0

    r0
  end

  module AllOp0
    def to_mongo; "$all"; end
  end

  def _nt_all_op
    start_index = index
    if node_cache[:all_op].has_key?(index)
      cached = node_cache[:all_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('all', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('all')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('ALL', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 3))
        r2.extend(AllOp0)
        @index += 3
      else
        terminal_parse_failure('ALL')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:all_op][start_index] = r0

    r0
  end

  module SizeOp0
    def to_mongo; "$size"; end
  end

  def _nt_size_op
    start_index = index
    if node_cache[:size_op].has_key?(index)
      cached = node_cache[:size_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('size', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('size')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('SIZE', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 4))
        r2.extend(SizeOp0)
        @index += 4
      else
        terminal_parse_failure('SIZE')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:size_op][start_index] = r0

    r0
  end

  module ExistsOp0
    def to_mongo; "$exists"; end
  end

  def _nt_exists_op
    start_index = index
    if node_cache[:exists_op].has_key?(index)
      cached = node_cache[:exists_op][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('exists', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure('exists')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('EXISTS', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 6))
        r2.extend(ExistsOp0)
        @index += 6
      else
        terminal_parse_failure('EXISTS')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:exists_op][start_index] = r0

    r0
  end

  def _nt_literal
    start_index = index
    if node_cache[:literal].has_key?(index)
      cached = node_cache[:literal][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    r1 = _nt_string
    if r1
      r0 = r1
    else
      r2 = _nt_number
      if r2
        r0 = r2
      else
        r3 = _nt_boolean
        if r3
          r0 = r3
        else
          r4 = _nt_regex
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:literal][start_index] = r0

    r0
  end

  def _nt_number
    start_index = index
    if node_cache[:number].has_key?(index)
      cached = node_cache[:number][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    r1 = _nt_float
    if r1
      r0 = r1
    else
      r2 = _nt_integer
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:number][start_index] = r0

    r0
  end

  module Float0
  end

  module Float1
    def to_mongo
      text_value.to_f
    end
  end

  def _nt_float
    start_index = index
    if node_cache[:float].has_key?(index)
      cached = node_cache[:float][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[-+]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
      if r3
        if has_terminal?('.', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('.')
          r5 = nil
        end
        s0 << r5
        if r5
          s6, i6 = [], index
          loop do
            if has_terminal?('\G[0-9]', true, index)
              r7 = true
              @index += 1
            else
              r7 = nil
            end
            if r7
              s6 << r7
            else
              break
            end
          end
          if s6.empty?
            @index = i6
            r6 = nil
          else
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          end
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Float0)
      r0.extend(Float1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:float][start_index] = r0

    r0
  end

  module Integer0
  end

  module Integer1
    def to_mongo
      text_value.to_i
    end
  end

  def _nt_integer
    start_index = index
    if node_cache[:integer].has_key?(index)
      cached = node_cache[:integer][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[-+]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Integer0)
      r0.extend(Integer1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:integer][start_index] = r0

    r0
  end

  module String0
    def to_mongo
      text_value[1...-1]
    end
  end

  def _nt_string
    start_index = index
    if node_cache[:string].has_key?(index)
      cached = node_cache[:string][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    r1 = _nt_double_quote_string
    if r1
      r0 = r1
      r0.extend(String0)
    else
      r2 = _nt_single_quote_string
      if r2
        r0 = r2
        r0.extend(String0)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:string][start_index] = r0

    r0
  end

  module DoubleQuoteString0
  end

  def _nt_double_quote_string
    start_index = index
    if node_cache[:double_quote_string].has_key?(index)
      cached = node_cache[:double_quote_string][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('"', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        if has_terminal?('\"', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('\"')
          r4 = nil
        end
        if r4
          r3 = r4
        else
          if has_terminal?('\\', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('\\')
            r5 = nil
          end
          if r5
            r3 = r5
          else
            if has_terminal?('\G[^"]', true, index)
              r6 = true
              @index += 1
            else
              r6 = nil
            end
            if r6
              r3 = r6
            else
              @index = i3
              r3 = nil
            end
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?('"', false, index)
          r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r7 = nil
        end
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DoubleQuoteString0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:double_quote_string][start_index] = r0

    r0
  end

  module SingleQuoteString0
  end

  def _nt_single_quote_string
    start_index = index
    if node_cache[:single_quote_string].has_key?(index)
      cached = node_cache[:single_quote_string][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("'", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("'")
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        if has_terminal?("\\'", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("\\'")
          r4 = nil
        end
        if r4
          r3 = r4
        else
          if has_terminal?('\\', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('\\')
            r5 = nil
          end
          if r5
            r3 = r5
          else
            if has_terminal?('\G[^\']', true, index)
              r6 = true
              @index += 1
            else
              r6 = nil
            end
            if r6
              r3 = r6
            else
              @index = i3
              r3 = nil
            end
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?("'", false, index)
          r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("'")
          r7 = nil
        end
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SingleQuoteString0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:single_quote_string][start_index] = r0

    r0
  end

  module Boolean0
    def to_mongo; true;  end
  end

  module Boolean1
    def to_mongo; false; end
  end

  def _nt_boolean
    start_index = index
    if node_cache[:boolean].has_key?(index)
      cached = node_cache[:boolean][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    if has_terminal?('true', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      r1.extend(Boolean0)
      @index += 4
    else
      terminal_parse_failure('true')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('false', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
        r2.extend(Boolean1)
        @index += 5
      else
        terminal_parse_failure('false')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:boolean][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      @index = cached.interval.end if cached
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[ \\n\\t]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

    node_cache[:space][start_index] = r0

    r0
  end

  module Regex0
  end

  module Regex1
    def to_mongo
      Regexp.new(text_value[1...-1])
    end
  end

  def _nt_regex
    start_index = index
    if node_cache[:regex].has_key?(index)
      cached = node_cache[:regex][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('/', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('/')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[^/]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        if has_terminal?('/', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('/')
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Regex0)
      r0.extend(Regex1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:regex][start_index] = r0

    r0
  end

  module FieldName0
    def single_field_name
      elements[0]
    end

    def field_name
      elements[2]
    end
  end

  module FieldName1
    def to_mongo
      text_value
    end
  end

  def _nt_field_name
    start_index = index
    if node_cache[:field_name].has_key?(index)
      cached = node_cache[:field_name][index]
      @index = cached.interval.end if cached
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_single_field_name
    s1 << r2
    if r2
      if has_terminal?('.', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('.')
        r3 = nil
      end
      s1 << r3
      if r3
        r4 = _nt_field_name
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(FieldName0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(FieldName1)
    else
      r5 = _nt_single_field_name
      if r5
        r0 = r5
        r0.extend(FieldName1)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:field_name][start_index] = r0

    r0
  end

  def _nt_single_field_name
    start_index = index
    if node_cache[:single_field_name].has_key?(index)
      cached = node_cache[:single_field_name][index]
      @index = cached.interval.end if cached
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[a-zA-z0-9_-]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:single_field_name][start_index] = r0

    r0
  end

end

class MongoQueryGrammarParser < Treetop::Runtime::CompiledParser
  include MongoQueryGrammar
end
